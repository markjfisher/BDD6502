; TODO items

* Add kMusicCommandDefineSample with index, then remove duplicate sample data from kMusicCommandPlayNote



* AudioExpansion could probably do with a loop address and loop length to be used after the first values
	Could use a flip-flop to hold the state, which is reset when high length is written. This obviously adds complexity though.



* Add audio expansion prototype
	First single channel sound is working at the correct sample rate
	Multiple channel is also working
	* Attempt to convert a small mod/xm
		http://www.retrospekt.com.au/2020/05/tiny-music-a-massive-curated-collection-of-music-in-mod-xm-s3m-other-formats/
		https://www.dropbox.com/sh/yyxyrkin9uj76ie/AABYa381WWs8KXwsIIYo4_q7a?dl=0
		Need to find an up to 8 channel file that will fit within 64K for samples (without down sampling)
		Without too many complex voice controls would also help
		Potential music:
			**4 channels: C:\Users\Martin Piper\Downloads\tiny music\mods\artists\h0ffman\H0ffman - Freerunner.mod
			4 channels: C:\Users\Martin Piper\Downloads\tiny music\mods\artists\mortimer twang\Mortimer Twang - No Sellout.mod
			4 channels: C:\Users\Martin Piper\Downloads\tiny music\mods\artists\mygg\Mygg - Techno Focus.mod
			8 channels: C:\Users\Martin Piper\Downloads\tiny music\mods\artists\zabutom\Zabutom - Godsends.xm
			*4 channels: C:\Users\Martin Piper\Downloads\tiny music\mods\various\4Mat - One Bullet Symphony.xm

		Potential java libs for parsing and converting to semi-optimised 6502 suitable format:
			* http://www.javamod.de/
				http://www.javamod.de/javamod.html

			java -cp ./javamod.jar de.quippy.javamod.main.CommandLine "C:\Users\Martin Piper\Downloads\tiny music\mods\artists\h0ffman\H0ffman - Freerunner.mod"
			ProTracker mod with 31 samples and 4 channels using Protracker frequency table
			Loader code:
				C:\Users\Martin Piper\Downloads\javamod-source\source\de\quippy\javamod\multimedia\mod\loader\tracker\ProTrackerMod.java
			Player code:
				C:\Users\Martin Piper\Downloads\javamod-source\source\de\quippy\javamod\multimedia\mod\ModMixer.java
					startPlayback()
					Might be able to stub out openAudioDevice() and writeSampleDataToLine() and let it parse the file to get info from modMixer.mixIntoBuffer(LBuffer, RBuffer, bufferSize);
				C:\Users\Martin Piper\Downloads\javamod-source\source\de\quippy\javamod\multimedia\mod\mixer\BasicModMixer.java
					mixIntoBuffer(final int[] leftBuffer, final int[] rightBuffer, final int count)
						mixChannelIntoBuffers(final int[] leftBuffer, final int[] rightBuffer, final int startIndex, final int endIndex, final ChannelMemory actMemo)
						Uses:	C:\Users\Martin Piper\Downloads\javamod-source\source\de\quippy\javamod\multimedia\mod\mixer\ProTrackerMixer.java
								C:\Users\Martin Piper\Downloads\javamod-source\source\de\quippy\javamod\multimedia\mod\mixer\BasicModMixer.java
									ChannelMemory
					doTickEvents()
						Potentially more interesting for extracting note events
							Yes definitely a lot more interesting, might even be possible to just call this in a loop to quickly get all the info
				C:\Users\Martin Piper\Downloads\javamod-source\source\de\quippy\javamod\multimedia\mod\mixer\ProTrackerMixer.java
						doRowEffects()
			Some options for export here:
				mixIntoBuffer
					Can export all relevant changes in ChannelMemory
					By modifying mixChannelIntoBuffers()
			* First pass of importing music works, repeating samples are needed, many volume and pitch updates etc are missing.
				The sample frequency conversion (// Convert internal frequency to hardware values) seems to be correct




* Add _VBLANK to the proteus debug file write
	The $f8 displayV can then be waited for in the _VBLANK
	This would negate the writes during VBLANK optimisation though?
		See: // This check removes waits for display H/V positions during the VBLANK, the non-visible part of the frame


	
* To use the VideoHardware debug output, the hardware last two layers need to be swapped.
	Perhaps add a switch selector for different layer priorities into the layer select to allow runtime configuration?
	Extra (but disabled and not placed) logic has been added to the video layer



* Match the simulated hardware to the emulated video output, especially the right border, the emulation seems to be a little too far "in"
	Also match the mode7 tiles with the hardware, the left/top of the screen might need syncing slightly with _vynsc/_hsync timing and the dx/dy adds
		Probably 8 pixels



* Real hardware found a bug where mode7 registers way beyond a011 were being written to (see target/DebugData.txt and find d$a02001)
	This needs to throw an exception in this emulation, for all the register sets in all layers



* Detect and fail if Bus24Bit_WaitVSync (the read from the register) is used without Bus24Bit_EnableDisplay (the register write)
	Or, allow the display enable/disable to just act on the output pixel stage and allow the counters to operate
	
	

* Image comparison needs to output a highlight of where the pixel differences are


* The contention time might need to be a bit longer considering the ageing speed with the 6502 speed
	Make the ageing and video clocks per instruction configurable, to allow a fast or slow 6502 to be emulated



* Have a separate section that animates for a few frames for "// Contention timing test"



* Read config for video display from command line



* I need some syntax that measures the percentage of code executed and memory accessed so I can have code coverage metrics during tests
  and fails if a test doesn't exercise what I think are important code paths



* Add cartridge support
	Read CRT files and store their banks and addresses into a map for easy lookup
	Add syntax to optionally configure cartridge bank address, whether it is read enabled
	Add syntax to specify combinatorial logic (use the variable resolution code ) on multiple locations and enable/disable carts banks, kernal/BASIC ROMs etc
		This can also support bank sizes by mapping cart banks with addresses
	Obviously more than one rule and multiple ROM binary or CRT files can be specified allowing complex cart bank/ROM arrangements to be created
	
	
	
* Add support for simulating IRQs and NMIs called via customised entry points and timings.
	For example FFFE or 0314 entry point can be specified directly



* Branch instructions followed by a $xx value must take into account the current PC and calculate the correct destination address before encriching the disassembly output



* Branch instructions must take into account the current ST and indicate of they will be taken, perhaps by highlighting the destination address



* Try to convert the PC to the nearest function label+XXX value by reading the debugger PDB output
