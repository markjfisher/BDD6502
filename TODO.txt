; TODO items

* Add _vsync to the proteus debug file write
	The $f8 displayV can then be waited for in the _vsync

	
* To use the VideoHardware debug output, the hardware last two layers need to be swapped.
	Perhaps add a switch selector for different layer priorities into the layer select to allow runtime configuration?



* Match the simulated hardware to the emulated video output, especially the right border, the emulation seems to be a little too far "in"
	Also match the mode7 tiles with the hardware, the left/top of the screen might need syncing slightly with _vynsc/_hsync timing and the dx/dy adds
		Probably 8 pixels



* Real hardware found a bug where mode7 registers way beyond a011 were being written to (see target/DebugData.txt and find d$a02001)
	This needs to throw an exception in this emulation, for all the register sets in all layers



* Detect and fail if Bus24Bit_WaitVSync (the read from the register) is used without Bus24Bit_EnableDisplay (the register write)
	Or, allow the display enable/disable to just act on the output pixel stage and allow the counters to operate
	
	

* Image comparison needs to output a highlight of where the pixel differences are


* The contention time might need to be a bit longer considering the ageing speed with the 6502 speed
	Make the ageing and video clocks per instruction configurable, to allow a fast or slow 6502 to be emulated



* Have a separate section that animates for a few frames for "// Contention timing test"



* Read config for video display from command line



* I need some syntax that measures the percentage of code executed and memory accessed so I can have code coverage metrics during tests
  and fails if a test doesn't exercise what I think are important code paths



* Add cartridge support
	Read CRT files and store their banks and addresses into a map for easy lookup
	Add syntax to optionally configure cartridge bank address, whether it is read enabled
	Add syntax to specify combinatorial logic (use the variable resolution code ) on multiple locations and enable/disable carts banks, kernal/BASIC ROMs etc
		This can also support bank sizes by mapping cart banks with addresses
	Obviously more than one rule and multiple ROM binary or CRT files can be specified allowing complex cart bank/ROM arrangements to be created
	
	
	
* Add support for simulating IRQs and NMIs called via customised entry points and timings.
	For example FFFE or 0314 entry point can be specified directly



* Branch instructions followed by a $xx value must take into account the current PC and calculate the correct destination address before encriching the disassembly output



* Branch instructions must take into account the current ST and indicate of they will be taken, perhaps by highlighting the destination address



* Try to convert the PC to the nearest function label+XXX value by reading the debugger PDB output
