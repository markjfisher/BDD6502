; Done items

Added: Given I am using C64 processor port options
	This stops writes to the IO registers from going to RAM



* Add emulated BombJack display
	https://github.com/martinpiper/BombJack/blob/master/README.md
	Sprites notes
		0x = far left visible screen pixel
		Done 0y = 16x16 Top of the sprite just below the bottom edge of the visible screen
		Done 0y = 32x32 Middle horizontal part of the sprite just below the bottom edge of the visible screen
	Add 32x32 sprites 9a00-9a01 (largeSprite)
		Done - Check the hardware for how the inclusive register really works with regards to using sprite update slots
			0-3	 No 32x32
			0-4	 Sprite 0 is 32x32, sprite 1 is not drawn, sprites 2 onwards are drawn
			0-5	 Sprite 0,2 is 32x32, sprite 1,3 is not drawn, sprites 4 onwards are drawn
			0-6	 Sprite 0,2,4 is 32x32, sprite 1,3,5 is not drawn, sprites 6 onwards are drawn
			0-7	 Sprite 0,2,4,6 is 32x32, sprite 1,3,5,7 is not drawn, sprites 8 onwards are drawn

			1-4	 Sprite 0 is 32x32, sprite 1 is not drawn, sprites 2 onwards are drawn
			2-4	 Same
			3-4	 Same
			4-4	 No 32x32
			4-5	 Sprites 0-1 are normal, Sprite 2 is 32x32, Sprite 3 is not drawn, sprites 4 onwards are drawn

			5-4	 Sprites 0-1 are normal, Sprite 2 is 32x32, Sprite 3 is not drawn, sprites 4 onwards are drawn
			5-5	 No 32x32
			6-5	 Sprites 0-3 are normal, Sprite 4 is 32x32, Sprite 5 is not drawn, sprites 6 onwards are drawn
			7-5	 Sprites 0-3 are normal, Sprite 4,6 is 32x32, Sprite 5,7 is not drawn, sprites 8 onwards are drawn

			1-5	 Sprite 0,2 is 32x32, sprite 1,3 is not drawn, sprites 4 onwards are drawn
			2-5	 Same


			Does it skip the next sprite?
				Yes
			What about the odd numbers sprites for the ranges?
				No, not the lines into 5R 5S
		Also the sprite frame, does it multiply the sprite frame to ensure it is aligned?
			Yes, it multiplies by 4
			What is the sprite layout?
				01
				23
	Do sprites off the far right appear on the left?
		Yes
	Do sprites off the bottom appear on the top?
		No.
	Done - Add full height mode (fullHeightSprite)



* Emulated hardware display
	When allocating layers, make the address and addressEx configurable
	TODO: Address configs for addressEx=0x01 need to respect the INRAMSEL1 groups 0x8000 0x8800 0x9000 0x9800 ... 0xb800 as these used for selection on each board
		Video board uses fixed address, not configurable.

		
		
* To correctly handle the "lo ENABLEPIXELS (with no border flags)" at 0x189H
	And to handle the hardware plane shifting, which introduces an 8 pixel delay
	The tiles and chars need to latch the Y position at the start of their reads for each tile/char 8 pixel span
	* Sprites also needed this fix, actually it was the sprite span pixel read and clear that gave the hint about the latch
	* See: latchedDisplayV
	* The mode7 layer does not have this problem because it maintains its own pixel clocks from hsync and vsync



* Continue adding syntax to support the other video layers
	features\TestVideoHardware.feature



* Detect when the 24 bit bus is held with an address for an extended number of cycles without data being written
	No need now, the hardware automatically resets the bus a while after the byte is written if another write has not been started



* displayBombJack.isVsyncTriggered
	The $dd0d value is reading the logic level of vsync in the display, it technically doesn't need the reset logic
	However the vsync wait will need a wait for "not vync" if a wait for vsync is issued too quickly after the first wait



* Optional syntax to limit the speed to XX FPS for video display


* Add arrows+ctrl as joystick1 ($dc00) for the video display window



* Output the software bus writes so that the Proteus simulator can use. Will need to detect waits for vsync or log x/y pos for writes



* Using target/debugData.txt the real hardware isn't displaying the high mode7 characters?
	* Mode7Regs2Size and Mode7Regs3Size are wrong, causing strange memory overwrites
	* Verified, by filling map.bin, that tile $02 and $22 are actually rendered
	* The palette used in the tile was the same as the background colour, so it was "invisible".
	* However the palette was being written strangely by the contention test code

	
	
* Twiddle the mode7 HV flips to align them with tiles



* The java video hardware test mode output debug file does not quite render correctly on the hardware
	The raster bars and perspective mode7 part is alternating every frame. Probably something to do with the output displayV not quite catching up properly
	Investigate if the "w$ff01ff00,$ff019000" is not being caught correctly
	It seems waiting for the last line and trying to do all the updates it not working out timing wise
		Removing the wait for line $ff and moving the sprite update to just after the vsync wait worked
	* TODO: Investigate, do we want to want for -ve _VSYNC or -ve VBLANK as it is currently going into the digital data simulator?
		Look at when the better, earlier, timing is just off the bottom of the screen
			VBLANK is better
		* The BDD6502 emulation will need to align the wait to vsync or vblank of course, to match with what the simulator does
	* _VBLANK checking aligned with simulation and emulation
